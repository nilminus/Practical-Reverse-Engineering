Execution state is ARM: All instruction are 32-bit
Function prologue Line 1: Stores register r4-r8 to the stack, SP = SP - 20 (5 registers)
Function epilogue Line 41: Restores registers r4-r8 from the stack, SP = SP + 20 (5 registers)

Function returns boolean: loc_B30C -> return 0;
                          loc_B33C -> return 1;

BOOL unk_function(char *str, arg2);



/* Line 3:
r3 = (byte) *str;
if (r3 == "-"){                // Looks like 1st parameter is ascii "-"
    r3 = (byte) (str + 1);     // 2nd character from str, r0 ++ (2nd character)
    r6 = 1;
} else {
    r6 = 0;
    if (r3 == "+")             // + 
        r3 = (byte) str + 1);  // Point to 2nd character
} /*

BOOL negatif;
if (*str == "-"){
    str++;                      // Point to 2nd character
    negatif = TRUE;             // Number is negative
} else {
    negatif = FALSE;            // Number is positive
    if (*str == "+"){
        str++;                  // If there is a plus sign, point to 2nd character
        
    }
}

/* Check if first number is zero.
Enter loop increasing str pointer while character is zero (0) */

while (*str == "0"){            // Eliminate leading zeroes (e.g. -0000032)
    str++;                      // str will point to start of actual number
}

/* 
i = 0                           // i = r12 = 0 Points to first character
r4 = 0
r5 = 0
r8 = 10         // "\n" ?

r7 = *(str + i)               // r7 = first number
i++                           // Points to index of number in parameter string
UMULL r2, r3, r4, r8            // Unsigned 64bit multiplication of two 32-bit registers
                                // r3,r2 = r4*r8  (0)
                                // r2 holds the partial result of multiplication
r7 = r7 - 30;                   // Sets flags, r7 contains a number from 30-39
                                // After substracting, its the actual number

if r7 >= 0:
        
    r3 = (r8 * r5) + r3             // Rd := (Rn + (Rm * Rs))[31:0]
                                    // MLA Multiply and accumulate
                                    // r3 = 10 * 0 + number
    if r7 < 9:
        if i == 0xb:              // r12 == 11 ?
            return 0;
        else 
            r4 = r2 + r7            // Set flags
            r5 = r3 + r7>>31        // ASR = Signed division by 2^31
                                    // r5r4 = r3r2 + r7>>31,r7
